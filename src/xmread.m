function [M,nameData] = xmread(A,matrixNames)

%{
    > Reads matrices generated by OUTPUT4, unlimited number per file
    > Optional string array/char cell vector 'matrixNames' allows only
      matrices with names matching the input to be read
    > Standard nonsparse and BIGMAT = TRUE formats are accepted
    > The marices can be reassembled in sparse format if requested (not implemented)
%}

% Convert input to string / MOD 16.05.20 added matrixNames
    if ~isstring(A)             
        A = string(A);             
    end
    if exist('matrixNames','var') & ~isstring(matrixNames)                  % MOD 22.03.21 added exist('matrixNames','var') check
        matrixNames = string(matrixNames);
    end

% Identify matrix headers and row/col data lines
    nameFlag = "1P,";
    dataFlag = "  ";

    tmp  = find(startsWith(A,dataFlag));                                    % Includes blockStart lines
    mask = contains(A(tmp),nameFlag);
    
% Iindices of matrix headers/column data/last entry lines
    nameLines = tmp(mask);
    dataLines = tmp(~mask);
  	blockEnd  = [nameLines(2:numel(nameLines))-3; dataLines(numel(dataLines))-1];

% Matrix header data
    nameData = textscan(join(A(nameLines)),'%f%f%f%f%s%s','TextType','string');
    [ncols nrows form type name fmt] = nameData{:};
    
% Mask indicating which matrices to read
    if exist('matrixNames','var')
        maskMatr = false(size(name));
        for i = 1:numel(matrixNames)
            maskMatr = maskMatr|strcmpi(name,matrixNames(i));
        end
    else
        maskMatr = true(size(name));
    end

% Bigmat is a logical determining the output format
    bigmat  = nrows<0;
	nrows   = abs(nrows);
    
% Numbers written in case of real/complex matrices -> [1 1 2 2]
    nnums = 1+double(type>=3);
% Single R, Double R, Single C, Double C -> [1,2,2,4] words per number written
    nwords = type-double(type==3); 

% Vectors used to find rows containing matrix entries/column data
    indM = 1:numel(A);
    indD = zeros(size(indM));    
    indM(dataLines) = 0;
    indD(dataLines) = dataLines;
    
% Initialise outputs
    M = {};

% Loop over all matrices
    for i = find(maskMatr)'          % numel(name) // make M{i} - > M{1,2,...}

  	% Initialise M and maskM
        Mi = zeros(nrows(i),ncols(i));
        maskM = false(size(Mi));

    % Vector of all read matrix entries / faster than textscan by ~20%
        ind	 = indM(nameLines(i)+1:blockEnd(i));
        Atmp = join(A(ind(ind~=0)));
        R    = sscanf(Atmp,'%f');
   
	% Check if sscanf failed due to overly large Atmp [UPDATED: 18/3/18]
        if isempty(R)                                                       
            R = cell2mat(textscan(Atmp,'%f'));
        end
        
    % Vector of all read data entries / faster than textscan by ~20%
        ind1 = indD(nameLines(i)+1:blockEnd(i));
        Atmp = join(A(ind1(ind1~=0)),newline);
        D	 = cell2mat(textscan(Atmp,'%f%f%f','CollectOutput',1));         % Matrix of data lines  

	% Logical mask for reshaping R / trivial solution
        if ~bigmat(i)
            for s = 1:size(D,1)
             	maskM(D(s,2):(D(s,2)+D(s,3)/nnums(i)-1),D(s,1)) = true;
            end
        else
        	for s = 1:size(D,1)
              	if ~isnan(D(s,3))
                  	col = D(s,1);
                else
                    row = D(s,2);
                 	nvals = (D(s,1)-1)/nwords(i);
                	maskM(row:row+nvals-1,col) = true;
                end
            end
        end
        
	% For complex numbers only / type == 3 or 4
        if type(i)>=3
        	R = R(1:2:numel(R)-1) + sqrt(-1)*R(2:2:numel(R));
        end
        
    	Mi(maskM) = R;
     	M{end+1} = Mi;
            
    end % Matrix loop
    
% Update 'nameData' to only include the read matrices' data
    for i = 1:numel(nameData)
        nameData{i}(~maskMatr) = [];
    end
    
end

% FOR LARGE MATRICES:
%{
tic
R = [];
for i = 1:ceil(numel(ind)/1e6)
idx = ind(1e6*(i-1)+1:min(1e6*i,numel(ind)));
R = [R; sscanf(join(A(idx)),'%f')];
A(idx) = "";
disp([i numel(A) toc]);
end
%}



